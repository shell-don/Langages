#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Author : Mathis PigassouCorrection des Travaux Pratiques :     TP 5 - listes, tris    TP 6 - tris de liste, recursivite    TP 7 - recursivite"""# Exercice 1def entiers_pairs() -> list :    '''    Liste contenant tous les entiers pairs compris entre 3 et 59.    '''    return [x for x in range(3,59) if x % 2 == 0]def mul_4_pas_mul_8() -> list :    '''    Liste contenant tous les nombres entiers naturels     inférieurs ou égaux à 1000 qui soient multiples de 4     mais non multiples de 8.    '''    return [x for x in range(0,1000) if (x % 4 == 0) and (x % 8 != 0) ]def diviseurs_2621970() -> list :     '''    Liste des diviseurs de 2621970.        '''    return  [x for x in range(1,2621970+1) if  2621970 % x == 0]def listediviseurs(n: int) -> list :    '''    Renvoie la liste des diviseurs de n.    '''    return  [x for x in range(1,n+1) if  n % x == 0]def isprime(n: int) -> bool :    '''    Test de primalité simple.        '''    if len(listediviseurs(n)) == 2 :        return True    else :        return False        def liste_Mersenne() -> list :    '''    Liste des premiers entiers premiers qui sont de la forme 2p−1 avec p premier.    '''    return  [(2**x)-1 for x in range(0,20) if isprime(x) ]# Exercice 2 def maxi (l: list, n: int) -> int :    '''    Renvoie l'indice du maximum des n premiers éléments de l.        '''    sl = l[ : n ]    return sl.index(max(sl))def tri_selection(liste: list) -> list :    '''    Renvoie une version triée de la liste via l’algorithme de tri par insertion.        '''    for k in range(len(liste), 1, -1) :        i = maxi(liste, k)        liste[i], liste[k-1] = liste[k-1], liste[i]    return liste # Exercice 3def insertion(liste: list, n: int) -> list :    '''    prend en argument une liste dont on suppose les n premiers     éléments déjà triés et qui insère l[n] à sa place parmi les n premiers éléments de l.        '''    while n>=0 and liste[n] > liste[n+1] :        liste[n], liste[n+1] = liste[n+1], liste[n]        n -= 1    return listedef tri_insertion(liste: list) -> list :    for i in range(1,len(liste)) :        insertion(liste, i-1)    return liste        # Exercice 4def factorielle(n) :    if n == 0 :        return 1     else :        return n*factorielle(n-1)# Exercice 5def expo(a: int, n: int) -> int :    '''    Algorithme d'exponentiation de type « diviser pour régner ».    '''    if n==0 :        return 1     else :        if n%2 ==0 :            return expo(a,n//2)**2         else :            return a*expo(a,(n-1)//2)**2 # exercice 6def tri_rapide(liste: list) -> list :    if liste == [] :        return []    else :        liste1 = [x for x in liste[1:] if x < liste[0]]        liste2 = [x for x in liste[1:] if x >= liste[0]]        return tri_rapide(liste1)+[liste[0]]+tri_rapide(liste2)    # Exercice 7def Lucas(p) :    """     Test de primalité de Lucas-Lhemer.    Vérifie si 2^p - 1 est premier, avec p premier différent de 2.        """    Mp = expo(2,p)-1    L = 4    for i in range(1,p-1) :        L = (L*L-2) % Mp    return L == 0def test() -> None :        # Exercice 1    print(len(diviseurs_2621970()))    print(len(listediviseurs(2621970)))    print(liste_Mersenne())        # Exercice 4    [factorielle(i) for i in range(101)]    print(len(str(factorielle(100))))        # Exercice 5    print(expo(99,99))        # Exercice 7    print(Lucas(127))        