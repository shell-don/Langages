#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Author : Mathis PigassouCorrection des Travaux Pratiques :     TP 14 - méthode de Newton"""import math as mimport numpy as npimport matplotlib.pyplot as plt# Exercice 1def f(x) :    return m.log(x)+xdef fp(x) :    return (1/x)+1def trace(f,fp,a,b,n,c) :    """     trace la courbe de f sur le segment [a; b]     en calculant n points et aﬃche la tangente en c.    """    abscis = np.linspace(a,b,n)    ordo = [f(x) for x in abscis]    ordo_tengente = [f(c)+fp(c)*(x-c) for x in abscis]    plt.plot(abscis, ordo_tengente)    plt.plot(abscis, ordo)# Exercice 2def newton(f, fp, x0, n) :    """     Supposons f dérivable sur l'intervalle dans lequel     on cherche la solution, de dérivé fp.    Renvoie une approximation de la solution à l'équation f (x) = 0    """    x = x0    for i in range(n) :        if fp(x) == 0 :            return -1        else :            x = x - f(x)/fp(x)    return xdef f2(x) :    return m.log(x+1)-((x-1)**2)def fp2(x) :    return 1/(x+1)-2*x+2# L'algorithme de Newton est plus efficace que celui de dichotomie# mais nécessite de connaitre la dérivé de f et est sensible au point de départdef test() -> None :        # Exercice 1    trace(f, fp,1e-3,5,1000,1)        # Exercice 2    n1 = newton(f2,fp2,1.4,10)    n2 = newton(f2,fp2,1.2,10)    trace(f2,fp2,-0.99,4,1000,n1)    trace(f2,fp2,-0.99,4,1000,n2)    plt.show        test()