#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Author : Mathis PigassouCorrection des Travaux Pratiques :     TP 12 - séries, séries semi-convergentes"""import matplotlib.pyplot as plt# Exercice 1 def u(n: int) -> any :    '''    Renvoie le terme d'indice n de la suite u (série harmonique).    '''    if n == 0 :        return "Erreur : division par 0"    else :        return ((-1)**(n+1))/n        def S(n: int) -> int :    '''    Renvoie la somme partielle des u.        '''    return sum(u(k) for k in range(1,n+1))def Sabs(n: int) -> int :    '''    Renvoie le terme d’indice n de la série de terme général |u|.        '''    return sum(abs(u(k)) for k in range(1,n+1))# Exercice 2def up(n: int) -> int :    '''    Terme de u positif.    '''    if u(n) > 0 :         return u(n)    else :        return 0        def um(n: int) -> int :    '''    Terme de u négatif.    '''    if u(n) > 0 :        return 0    else :        return -u(n)        def S_up(n: int) -> int :    '''    Somme partielle des u+.    '''    return sum(up(k) for k in range(1,n+1))def S_um(n: int) -> int :    '''    Somme partielle des u-.    '''    return sum(um(k) for k in range(1,n+1))# Exercice 3def prochain_positif(u, n: int) -> int :    '''    Renvoie le premier indice k supérieur strictement à n tel que uk 0.    '''    if u(n+1) > 0 :        return n+1    else :        return prochain_positif(u, n+1)        def prochain_negatif(u, n: int) -> int :    if u(n+1) < 0 :        return n+1    else :        return prochain_negatif(u, n+1)# Exercice 4def riemann(u, limite, eps) :    """     u : une série semi-convergente    limte : une limite    eps : précision epsilon    renvoie une liste d'indices phi telle que la somme des termes de u    de phi soit eps-proche de limite.        """    positifs = []    negatifs = []    phi = []    somme = 0    while abs(somme-limite) > eps :        if somme <= limite :            if len(positifs) == 0 :                n = prochain_positif(u, 0)            else :                n = prochain_positif(u, positifs[-1])            positifs.append(n)            phi.append(n)            somme += u(n)        else :            if len(negatifs) == 0 :                n = prochain_negatif(u, 0)            else :                    n = prochain_negatif(u, negatifs[-1])            negatifs.append(n)            phi.append(n)            somme += u(n)    return phidef test() -> None :        # Exercice 1    abscis = [k for k in range(2000)]    ordo_u = [S(k) for k in abscis]    ordo_abs_u = [Sabs(k) for k in abscis]    plt.plot(abscis, ordo_u )    plt.plot(abscis, ordo_abs_u)        # Exercice 2    ordo_up = [S_up(k) for k in abscis]    ordo_um = [S_um(k) for k in abscis]    plt.plot(abscis, ordo_up)    plt.plot(abscis, ordo_um)    plt.show    # Exercice 4    print(riemann(u,0.8,1e-4))test()