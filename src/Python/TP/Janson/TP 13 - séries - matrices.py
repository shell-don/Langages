#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Author : Mathis PigassouCorrection des Travaux Pratiques :     TP 13 - series - matrices"""import numpy as npimport math as mimport matplotlib.pyplot as plt# Exercice 1def u(n) :    if n == 0 :         return "Erreur : division par 0"    else :        return 1/ndef S(u, n) :    return sum(u(k) for k in range(1,n+1))def v(n) :    if n == 0 :        return "Erreur : valeur interdite"    else :        return S(u,n)-m.log(n)    # L'écart entre v_n et γest au plus 1/n.# Autrement dit, plus n est grand, plus v_n est proche de γ.# Donc Pour garantir que ∣v_n −γ∣≤ eps, il suffit de choisir n assez# grand pour que 1/n ≤ eps.# ce qui donne n=floor(1 / eps)+1def approx_gamma(v, eps) :    n = m.floor(1 / eps) + 1    return v(n)# Exercice 2def multlig(a, i, A) :    (p,n) = A.shape    B = A     for j in range(n) :        B[i,j] = a*B[i,j]    return Bdef addlig(b, i, j, A) :    (p,n) = A.shape    B = multlig(b, j, A)    for x in range(n) :        A[i, x] = A[i,x] + B[j,x]      return Adef echlig(i, j, A) :    temp = A[i, :].copy()      A[i, :] = A[j, :]          A[j, :] = temp     return A# D est une matrice de dilatation donc elle multipliera la # i-ième ligne de A par a.def multiligmat(a,i,A) :    """     Via D, une matrice de dilatation.        """    (p,n) = A.shape    D = np.eye(p)    D[i,i] = a     return np.dot(D,A)def echligmat(i, j, A) :    """     Via P, une matrice de permutation.        """    (p,n) = A.shape    P = np.eye(n)    P[[i,j]] = P[[j,i]]    return np.dot(P,A)def addligmat(b, i, j, A) :    """     Via T, une matrice de transvection.        """    (p,n) = A.shape()    T = np.eye(n)    T[i,j] = b    return np.dot(T,A)# La matrice de dilatation est inversible car c'est une matrice diagonale dont tous les coefficients sont non nuls# La matrice de permutation est orthogonale, ce qui signifie que P*P^t = I, donc P est inversible et son inverse vaut P^t# La matrice de transvection est triangulaire supérieure ou inférieure avec des coefficients diagonaux non nuls, donc inversible.def test() -> None :        abscis = [k for k in range(1,501)]    ordo = [v(k) for k in abscis]    plt.plot(abscis, ordo)    plt.show        print(approx_gamma(v, 1e-4))    test()