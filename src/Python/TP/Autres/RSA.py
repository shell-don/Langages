#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Author : Mathis PigassouD√©monstration simplifi√© d'RSA."""import mathdef indicatrice_euleur(p: int, q: int) -> int :    '''    Renvoie l'indicatrice d'Euler.     Essentiel pour trouver e (cl√© publique).    '''    return (p-1)*(q-1)def euclide_etendu(a: int, b: int) -> tuple :    '''    Renvoie (PGCD(a, b), u, v) o√π u et v sont les coefficients de B√©zout. (ie au +bv = PGCD(a,b))/    '''    u_0 = 1 ; u_1 = 0    v_0 = 0 ; v_1 = 1    while b != 0 :        q: int = a // b        a, b = b, a % b        u_1, u_0 = u_0 - q*u_1, u_1        v_1, v_0 = v_0 - q*v_1, v_1    return (a, u_0, v_0)def inverse(a: int, n: int) -> int :    '''    Renvoie l'inverse de a modulo n.    Essentiel pour trouver d (cl√© priv√©).        '''    PGCD, u, v = euclide_etendu(a, n)    if PGCD != 1 :        return 0    else :        return u % n    def trouver_e(phi: int) -> int :    '''    Renvoie le premier entier premier avec phi(n).    '''    for e in range(2, phi-1) :        if math.gcd(e, phi) == 1 :            return e    return -1def chiffrement(m: int, e: int, n: int) -> int :    '''    Chiffrement du message m.    '''    return pow(m, e, n)def dechiffrement(ciphertext: int, d: int, n: int) -> int :    '''    D√©chiffrement du ciphertext.    '''    return pow(ciphertext, d, n)def encode(message: str) -> list :    '''    Renvoie le message initial en une liste de nombres.        '''    return list(message.encode("utf-8"))def decode(liste: list) -> str :    '''    D√©code une liste d'entier en une chaine de caract√®re.        '''    return bytes(liste).decode("utf-8")def cle_publique(p: int, q: int) -> tuple :    '''    Renvoie le couple (n, e). Ici e est donn√©, il doit √™tre choisi.        '''    n: int = p*q    phi: int = indicatrice_euleur(p, q)    e: int = trouver_e(phi)    return (n, e)def cle_privee(p: int, q: int) -> tuple :    '''    Renvoie la cl√© priv√©e (d) √† partir de la cl√© publique.     p et q sont suppos√© √™tre les m√™me que ceux de la cl√© publique.         '''    n: int = p*q    phi: int = indicatrice_euleur(p, q)    e: int = trouver_e(phi)    return (n, inverse(e, phi))def chiffrement_RSA(message: str, cle_publique: tuple) -> list :    '''    Chiffre le message d'apr√®s RSA.    '''    n, e = cle_publique    ciphertext: list = [chiffrement(x, e, n) for x in encode(message)]    return ciphertextdef dechiffrement_RSA(ciphertext: str, cle_privee: tuple) -> list :    '''    D√©chiffre le message d'apr√®s RSA.        '''    n, d = cle_privee    message: list = [dechiffrement(x, d, n)  for x in ciphertext]    return messagedef test() -> bool :        assert encode("ü§Ø") == [240, 159, 164, 175], "√âchec test 1 : encode()"    assert decode([240, 159, 164, 175]) == "ü§Ø", "√âchec test 2 : decode()"        assert chiffrement(10, 5, 85) == 40, "√âchec test 3 : chiffrement()"    assert dechiffrement(40, 13, 85) == 10, "√âchec test 4 : dechiffrement()"        assert cle_publique(65537, 17) == (1114129, 3), "√âchec test 5 : cle_publique()"    assert cle_privee(65537,17) == (1114129, 699051), "√âchec test 6 : cle_privee()"        return True    def main() -> None :    '''    Chiffrement RSA appliqu√© au cas suivant : Bob envoie "Bonjour" √† Alice.    Alice √† choisie p = 65537 et q = 17. Donc e = 3 (possible de choisir)    '''    if test() :        # Bob r√©cup√®re la cl√© publique d'Alice.        cle_public_Alice:tuple = cle_publique(65537, 17)        cle_privee_Alice:tuple = cle_privee(65537, 17)        # Bob chiffre le message et envoi x √† Alice.        x: list = chiffrement_RSA("Hello World !", cle_public_Alice)        print(x)        # Alice re√ßoit le message le d√©chiffre et le transforme en chaine de caract√®re.        print(decode(dechiffrement_RSA( x , cle_privee_Alice)))        return    print(-1)    return             main()